apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-ui
  labels:
    {{- include "nereid.labels" . | nindent 4 }}
data:
  default.conf: |
    server {
      listen 8080;
      server_name _;
      root /usr/share/nginx/html;

      add_header Cache-Control "no-store, no-cache, must-revalidate, max-age=0" always;
      add_header Pragma "no-cache" always;
      add_header Expires "0" always;

      location / {
        try_files $uri $uri/ /index.html;
      }
    }
  index.html: |
    <!doctype html>
    <html>
      <head>
        <meta charset="utf-8"/>
        <meta name="viewport" content="width=device-width,initial-scale=1"/>
        <title>NEREID Playground</title>
        <style>
          :root {
            --bg: #f6f8fb;
            --panel: #ffffff;
            --ink: #13233a;
            --muted: #5c6f88;
            --line: #d7e0eb;
            --brand: #2c6bff;
            --brand-ink: #ffffff;
          }
          * { box-sizing: border-box; }
          body {
            margin: 0;
            font-family: "Avenir Next", "Hiragino Kaku Gothic ProN", "Yu Gothic", sans-serif;
            color: var(--ink);
            background:
              radial-gradient(1200px 600px at 8% -20%, #dbe7ff 0%, rgba(219, 231, 255, 0) 70%),
              radial-gradient(900px 480px at 110% -10%, #d8fff3 0%, rgba(216, 255, 243, 0) 65%),
              var(--bg);
            min-height: 100vh;
          }
          .shell {
            width: min(1100px, 94vw);
            margin: 28px auto;
          }
          .headline {
            margin-bottom: 14px;
          }
          h1 {
            margin: 0 0 6px 0;
            font-size: clamp(26px, 4vw, 44px);
            letter-spacing: 0.01em;
          }
          .sub {
            margin: 0;
            color: var(--muted);
            font-size: 14px;
          }
          .grid {
            display: grid;
            grid-template-columns: 1.15fr 0.85fr;
            gap: 14px;
          }
          @media (max-width: 880px) {
            .grid { grid-template-columns: 1fr; }
          }
          .card {
            background: var(--panel);
            border: 1px solid var(--line);
            border-radius: 18px;
            box-shadow: 0 12px 36px rgba(16, 40, 74, 0.08);
          }
          .left {
            padding: 16px;
          }
          .right {
            padding: 18px;
          }
          textarea {
            width: 100%;
            height: clamp(260px, 48vh, 420px);
            border-radius: 14px;
            border: 1px solid #c8d6e8;
            padding: 14px;
            resize: vertical;
            font-size: 16px;
            line-height: 1.6;
            color: #16283f;
            background: #fbfdff;
          }
          textarea:focus {
            outline: 2px solid #c7dbff;
            border-color: var(--brand);
          }
          .toolbar {
            margin-top: 12px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
          }
          button {
            border: 0;
            border-radius: 999px;
            background: var(--brand);
            color: var(--brand-ink);
            font-weight: 700;
            padding: 12px 20px;
            cursor: pointer;
          }
          button[disabled] { opacity: 0.55; cursor: wait; }
          .ghost {
            background: #eef3fb;
            color: #25466d;
            font-weight: 600;
          }
          .status {
            font-size: 15px;
            min-height: 24px;
            color: #1f4068;
          }
          .mono {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
            font-size: 12px;
            color: #436489;
            overflow-wrap: anywhere;
          }
          .pill {
            display: inline-block;
            border: 1px solid #c9d7ea;
            border-radius: 999px;
            padding: 4px 10px;
            font-size: 12px;
            color: #25466d;
            margin-right: 6px;
            margin-bottom: 6px;
          }
          .examples {
            margin-top: 14px;
          }
          .examples h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #284f78;
          }
          .eg {
            display: block;
            width: 100%;
            text-align: left;
            background: #f7fbff;
            color: #21456d;
            border: 1px solid #d1e0f0;
            border-radius: 10px;
            padding: 10px 11px;
            margin-bottom: 8px;
            font-size: 13px;
          }
          .recent-works {
            margin-top: 14px;
          }
          .recent-works h3 {
            margin: 0 0 8px 0;
            font-size: 14px;
            color: #284f78;
          }
          .recent-works-list {
            max-height: 138px;
            overflow: auto;
            border: 1px solid #d1e0f0;
            background: #f7fbff;
            border-radius: 10px;
            padding: 8px;
          }
          .recent-works-list a {
            display: block;
            color: #21456d;
            text-decoration: none;
            padding: 4px 2px;
            border-bottom: 1px dashed #d8e6f4;
          }
          .recent-works-list a:last-child {
            border-bottom: 0;
          }
          .recent-works-list a:hover {
            text-decoration: underline;
          }
          .status-stage {
            position: relative;
            margin-top: 12px;
            border-radius: 14px;
            border: 1px solid #b9cdef;
            padding: 12px;
            background:
              radial-gradient(circle at 20% 10%, rgba(66, 126, 255, 0.23), rgba(66, 126, 255, 0) 50%),
              radial-gradient(circle at 80% 90%, rgba(31, 176, 136, 0.22), rgba(31, 176, 136, 0) 50%),
              linear-gradient(135deg, #f7faff 0%, #ecf5ff 100%);
            overflow: hidden;
          }
          .status-stage::after {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(110deg, rgba(255,255,255,0) 10%, rgba(255,255,255,0.45) 45%, rgba(255,255,255,0) 80%);
            transform: translateX(-140%);
            animation: stage-shine 2.8s linear infinite;
            pointer-events: none;
          }
          @keyframes stage-shine {
            to { transform: translateX(140%); }
          }
          .orbital {
            display: grid;
            place-items: center;
            height: 96px;
            position: relative;
          }
          .orbital .ring {
            position: absolute;
            border-radius: 999px;
            border: 2px solid transparent;
          }
          .ring-a {
            width: 84px; height: 84px;
            border-top-color: #2f6fff;
            border-right-color: #2f6fff;
            animation: spin 1.6s linear infinite;
          }
          .ring-b {
            width: 62px; height: 62px;
            border-left-color: #17a188;
            border-bottom-color: #17a188;
            animation: spin-rev 1.2s linear infinite;
          }
          .ring-c {
            width: 42px; height: 42px;
            border-top-color: #ff7a1a;
            border-right-color: #ff7a1a;
            animation: spin 0.95s linear infinite;
          }
          @keyframes spin { to { transform: rotate(360deg); } }
          @keyframes spin-rev { to { transform: rotate(-360deg); } }
          .phase-chip {
            position: relative;
            z-index: 2;
            background: #ffffff;
            border: 1px solid #c0d3f1;
            border-radius: 999px;
            padding: 5px 11px;
            font-size: 11px;
            letter-spacing: 0.08em;
            font-weight: 800;
            color: #1b4f95;
            text-transform: uppercase;
            box-shadow: 0 4px 14px rgba(37, 79, 144, 0.18);
          }
          .progress-track {
            margin-top: 6px;
            height: 9px;
            border-radius: 999px;
            background: rgba(17, 50, 92, 0.14);
            overflow: hidden;
          }
          .progress-fill {
            height: 100%;
            width: 0%;
            border-radius: 999px;
            background: linear-gradient(90deg, #2f6fff, #20b69d, #ff8a2c);
            background-size: 200% 100%;
            transition: width 0.55s ease;
            animation: progress-move 1.25s linear infinite;
          }
          @keyframes progress-move {
            to { background-position: 200% 0; }
          }
          .phase-row {
            margin-top: 10px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
          }
          .phase-step {
            text-align: center;
            border-radius: 999px;
            border: 1px solid #bfd1ea;
            background: rgba(255, 255, 255, 0.82);
            color: #365980;
            font-size: 11px;
            padding: 4px 0;
            font-weight: 700;
            transition: transform 0.2s ease, border-color 0.2s ease, color 0.2s ease;
          }
          .phase-step.is-active {
            color: #0f3c7c;
            border-color: #3d7cff;
            transform: translateY(-1px);
          }
          .phase-step.is-done {
            color: #0b6e5d;
            border-color: #17a188;
          }
          .phase-meta {
            margin-top: 8px;
            text-align: center;
            font-size: 11px;
            color: #3d5f86;
            min-height: 16px;
          }
          .status-stage[data-mode="done"] .ring-a,
          .status-stage[data-mode="done"] .ring-b,
          .status-stage[data-mode="done"] .ring-c {
            animation-duration: 0.35s;
          }
          .status-stage[data-mode="error"] {
            border-color: #e8b8b8;
            background: linear-gradient(135deg, #fff5f5 0%, #fff0f0 100%);
          }
          .status-stage[data-mode="error"] .phase-chip {
            color: #8f1e1e;
            border-color: #e8b8b8;
          }
          .status-stage[data-mode="idle"] .ring-a,
          .status-stage[data-mode="idle"] .ring-b,
          .status-stage[data-mode="idle"] .ring-c {
            animation-play-state: paused;
            opacity: 0.45;
          }
          .embed-shell {
            width: 100vw;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
          }
          .embed-head {
            display: flex;
            gap: 10px;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            background: rgba(255,255,255,0.92);
            border: 1px solid var(--line);
            border-radius: 12px;
            padding: 8px 10px;
          }
          .embed-home-link {
            color: #14375f;
            text-decoration: none;
            font-weight: 800;
            letter-spacing: 0.01em;
          }
          .embed-home-link:hover {
            text-decoration: underline;
          }
          .embed-grid {
            display: grid;
            grid-template-columns: minmax(320px, 36vw) 1fr;
            gap: 10px;
            min-height: calc(100vh - 92px);
          }
          @media (max-width: 960px) {
            .embed-grid { grid-template-columns: 1fr; min-height: auto; }
          }
          .embed-log {
            background: #fff;
            border: 1px solid var(--line);
            border-radius: 12px;
            padding: 10px;
            overflow: auto;
          }
          .embed-log h3 {
            margin: 0 0 6px 0;
            font-size: 12px;
            color: #355a83;
            letter-spacing: 0.04em;
            text-transform: uppercase;
          }
          .embed-log pre {
            margin: 0 0 10px 0;
            white-space: pre-wrap;
            word-break: break-word;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
            font-size: 12px;
            line-height: 1.45;
            background: #f8fbff;
            border: 1px solid #dbe6f4;
            border-radius: 8px;
            padding: 8px;
            min-height: 96px;
            max-height: 42vh;
            overflow: auto;
          }
          .embed-followup {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px dashed #d4e2f2;
          }
          .embed-followup textarea {
            width: 100%;
            min-height: 86px;
            resize: vertical;
            border: 1px solid #c9d8eb;
            border-radius: 8px;
            padding: 8px;
            font: 12px/1.5 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
            background: #f8fbff;
            color: #1f2d3d;
            box-sizing: border-box;
          }
          .embed-followup .toolbar {
            margin-top: 8px;
          }
          .embed-followup .status {
            margin-top: 6px;
            min-height: 16px;
            font-size: 12px;
            color: #355a83;
          }
          .embed-frame-wrap {
            background: #fff;
            border: 1px solid var(--line);
            border-radius: 12px;
            overflow: hidden;
            min-height: 70vh;
          }
          .embed-status-stage {
            margin: 12px;
          }
          #embed-frame {
            width: 100%;
            min-height: 70vh;
            height: calc(100vh - 120px);
            border: 0;
            background: #f5f8fc;
          }
          @media (max-width: 960px) {
            #embed-frame { height: 62vh; }
          }
        </style>
      </head>
      <body>
        <main class="shell" id="playground-shell">
          <section class="headline">
            <h1>NEREID</h1>
            <p class="sub">Write what map you want. NEREID creates a Work, runs it, and opens the result when ready.</p>
          </section>

          <section class="grid">
            <article class="card left">
              <form id="prompt-form">
                <textarea id="prompt-input" placeholder="例: 東京都台東区の公園を表示してください。"></textarea>
                <div class="toolbar">
                  <button type="submit" id="submit-btn">Generate Map</button>
                  <button type="button" class="ghost" id="clear-btn">Clear</button>
                </div>
              </form>
            </article>

            <aside class="card right">
              <div>
                <span class="pill">Host: {{ .Values.host }}</span>
                <span class="pill">Runtime: k8s + Kueue</span>
                <span class="pill">Grant: ∞</span>
              </div>
              <div class="status-stage" id="status-stage" data-mode="idle">
                <div class="orbital">
                  <div class="ring ring-a"></div>
                  <div class="ring ring-b"></div>
                  <div class="ring ring-c"></div>
                  <div class="phase-chip" id="phase-chip">IDLE</div>
                </div>
                <div class="progress-track"><div class="progress-fill" id="progress-fill"></div></div>
                <div class="phase-row">
                  <div class="phase-step" id="step-submitted">SUBMITTED</div>
                  <div class="phase-step" id="step-running">RUNNING</div>
                  <div class="phase-step" id="step-succeeded">SUCCEEDED</div>
                </div>
                <div class="phase-meta" id="phase-meta">Waiting for input.</div>
              </div>
              <p id="status" class="status">Ready.</p>
              <div id="work-name" class="mono"></div>
              <div id="artifact-url" class="mono"></div>
              <div class="examples">
                <h3>Examples</h3>
                <button class="eg" type="button">東京都台東区の公園を表示してください。</button>
                <button class="eg" type="button">東京都台東区と東京都文京区と東京都江東区のセブンイレブンとファミリーマートとローソンを表示してください。</button>
                <button class="eg" type="button">国の名前を青色にしてください。川の名前を黄色にしてください。</button>
              </div>
              <div class="recent-works">
                <h3>Recent Works</h3>
                <div id="recent-works" class="recent-works-list mono">(none)</div>
              </div>
            </aside>
          </section>
        </main>

        <main class="embed-shell" id="embed-shell" style="display:none;">
          <section class="embed-head">
            <div>
              <a href="/" class="embed-home-link">NEREID Playground</a>
              <div id="embed-meta" class="mono"></div>
            </div>
            <a id="embed-open" class="ghost" target="_blank" rel="noopener noreferrer">Open Work</a>
          </section>
          <section class="embed-grid">
            <aside class="embed-log">
              <h3>User Input</h3>
              <pre id="embed-user">Waiting...</pre>
              <h3>Agent Dialogue</h3>
              <pre id="embed-dialogue">Waiting...</pre>
              <h3>Agent Log</h3>
              <pre id="embed-agent">Waiting...</pre>
              <div class="embed-followup" id="embed-followup">
                <h3>Follow-up Instruction</h3>
                <textarea id="followup-input" placeholder="追加の指示を入力してください。"></textarea>
                <div class="toolbar">
                  <button type="button" id="followup-btn">Send Follow-up</button>
                </div>
                <div id="followup-status" class="status mono"></div>
                <div class="recent-works">
                  <h3>Recent Works</h3>
                  <div id="embed-recent-works" class="recent-works-list mono">(none)</div>
                </div>
              </div>
            </aside>
            <div class="embed-frame-wrap">
              <div class="status-stage embed-status-stage" id="embed-status-stage" data-mode="idle" style="display:none;">
                <div class="orbital">
                  <div class="ring ring-a"></div>
                  <div class="ring ring-b"></div>
                  <div class="ring ring-c"></div>
                  <div class="phase-chip" id="embed-phase-chip">IDLE</div>
                </div>
                <div class="progress-track"><div class="progress-fill" id="embed-progress-fill"></div></div>
                <div class="phase-row">
                  <div class="phase-step" id="embed-step-submitted">SUBMITTED</div>
                  <div class="phase-step" id="embed-step-running">RUNNING</div>
                  <div class="phase-step" id="embed-step-succeeded">SUCCEEDED</div>
                </div>
                <div class="phase-meta" id="embed-phase-meta">Waiting for artifact.</div>
              </div>
              <iframe id="embed-frame" loading="lazy" referrerpolicy="no-referrer"></iframe>
            </div>
          </section>
        </main>

        <script>
          const form = document.getElementById("prompt-form");
          const input = document.getElementById("prompt-input");
          const statusEl = document.getElementById("status");
          const workNameEl = document.getElementById("work-name");
          const artifactEl = document.getElementById("artifact-url");
          const submitBtn = document.getElementById("submit-btn");
          const clearBtn = document.getElementById("clear-btn");
          const stageEl = document.getElementById("status-stage");
          const phaseChipEl = document.getElementById("phase-chip");
          const progressFillEl = document.getElementById("progress-fill");
          const phaseMetaEl = document.getElementById("phase-meta");
          const stepSubmittedEl = document.getElementById("step-submitted");
          const stepRunningEl = document.getElementById("step-running");
          const stepSucceededEl = document.getElementById("step-succeeded");
          let stageTicker = null;
          let embedRefreshTimer = null;
          let workStartedAt = 0;
          let lastPhase = "Idle";
          const playgroundShellEl = document.getElementById("playground-shell");
          const embedShellEl = document.getElementById("embed-shell");
          const embedFrameEl = document.getElementById("embed-frame");
          const embedOpenEl = document.getElementById("embed-open");
          const embedMetaEl = document.getElementById("embed-meta");
          const embedUserEl = document.getElementById("embed-user");
          const embedDialogueEl = document.getElementById("embed-dialogue");
          const embedAgentEl = document.getElementById("embed-agent");
          const embedStageEl = document.getElementById("embed-status-stage");
          const embedPhaseChipEl = document.getElementById("embed-phase-chip");
          const embedProgressFillEl = document.getElementById("embed-progress-fill");
          const embedPhaseMetaEl = document.getElementById("embed-phase-meta");
          const embedStepSubmittedEl = document.getElementById("embed-step-submitted");
          const embedStepRunningEl = document.getElementById("embed-step-running");
          const embedStepSucceededEl = document.getElementById("embed-step-succeeded");
          const embedFollowupEl = document.getElementById("embed-followup");
          const followupInputEl = document.getElementById("followup-input");
          const followupBtnEl = document.getElementById("followup-btn");
          const followupStatusEl = document.getElementById("followup-status");
          const recentWorksEl = document.getElementById("recent-works");
          const embedRecentWorksEl = document.getElementById("embed-recent-works");
          const rawArtifactsBase = "{{ .Values.artifacts.publicBaseUrl }}".replace(/\/+$/, "");
          const pageIsHTTPS = window.location.protocol === "https:";
          const defaultArtifactsBase = pageIsHTTPS ? rawArtifactsBase.replace(/^http:\/\//i, "https://") : rawArtifactsBase;
          const normalizedPath = (window.location.pathname || "/").replace(/\/+$/, "") || "/";
          const worksPathMatch = normalizedPath.match(/^\/works\/([^\/?#]+)$/);
          let workNameFromPath = "";
          if (worksPathMatch && worksPathMatch[1]) {
            try {
              workNameFromPath = decodeURIComponent(worksPathMatch[1]).trim();
            } catch (_) {
              workNameFromPath = String(worksPathMatch[1] || "").trim();
            }
          }
          const isEmbedMode = normalizedPath === "/embed" || workNameFromPath !== "";
          const workHistoryStorageKey = "nereid.recentWorkIds.v1";
          const workHistoryLimit = 40;
          let followupAllowed = false;
          let embedWorkStartedAt = 0;

          function normalizeArtifactUrl(raw) {
            const v = String(raw || "").trim();
            if (!v) return "";
            if (v.startsWith("http://") || v.startsWith("https://")) {
              const out = pageIsHTTPS ? v.replace(/^http:\/\//i, "https://") : v;
              return out.endsWith("/") ? out : (out + "/");
            }
            return "";
          }

          function artifactUrlForWork(workName) {
            if (!workName) return "";
            return defaultArtifactsBase + "/" + encodeURIComponent(workName) + "/";
          }

          function embedURLForWork(workName) {
            if (!workName) return "/embed";
            return "/works/" + encodeURIComponent(workName);
          }

          async function fetchStatus(workName) {
            const ts = Date.now();
            const res = await fetch("/api/status/" + encodeURIComponent(workName) + "?ts=" + ts, {
              method: "GET",
              cache: "no-store"
            });
            if (!res.ok) throw new Error("status API failed: " + res.status);
            return await res.json();
          }

          async function fetchText(url) {
            try {
              const res = await fetch(url + "?ts=" + Date.now(), { cache: "no-store" });
              if (!res.ok) return null;
              return await res.text();
            } catch (_) {
              return null;
            }
          }

          function escapeHTML(s) {
            return String(s || "")
              .replace(/&/g, "&amp;")
              .replace(/</g, "&lt;")
              .replace(/>/g, "&gt;");
          }

          function readRecentWorkIDs() {
            try {
              const raw = window.localStorage.getItem(workHistoryStorageKey);
              if (!raw) return [];
              const parsed = JSON.parse(raw);
              if (!Array.isArray(parsed)) return [];
              return parsed
                .map((v) => String(v || "").trim())
                .filter((v) => /^[a-z0-9][a-z0-9-]{6,252}$/.test(v));
            } catch (_) {
              return [];
            }
          }

          function saveRecentWorkIDs(ids) {
            try {
              window.localStorage.setItem(workHistoryStorageKey, JSON.stringify((ids || []).slice(0, workHistoryLimit)));
            } catch (_) {}
          }

          function renderRecentWorks() {
            const ids = readRecentWorkIDs();
            const targets = [recentWorksEl, embedRecentWorksEl].filter(Boolean);
            targets.forEach((el) => {
              if (!el) return;
              if (!ids.length) {
                el.textContent = "(none)";
                return;
              }
              el.innerHTML = ids
                .map((id) => "<a href=\"" + embedURLForWork(id) + "\">" + escapeHTML(id) + "</a>")
                .join("");
            });
          }

          function rememberWorkID(workName) {
            workName = String(workName || "").trim();
            if (!/^[a-z0-9][a-z0-9-]{6,252}$/.test(workName)) return;
            const ids = readRecentWorkIDs().filter((id) => id !== workName);
            ids.unshift(workName);
            saveRecentWorkIDs(ids);
            renderRecentWorks();
          }

          function updateEmbedStage(phase, message) {
            if (!embedStageEl || !embedPhaseChipEl || !embedProgressFillEl || !embedPhaseMetaEl) return;

            const current = String(phase || "Idle");
            const elapsedSec = embedWorkStartedAt > 0 ? (Date.now() - embedWorkStartedAt) / 1000 : 0;
            const progress = progressByPhase(current, elapsedSec);
            embedProgressFillEl.style.width = progress.toFixed(1) + "%";
            embedPhaseChipEl.textContent = current.toUpperCase();

            if (current === "Succeeded") embedStageEl.dataset.mode = "done";
            else if (current === "Failed" || current === "Error") embedStageEl.dataset.mode = "error";
            else if (current === "Submitted" || current === "Queued" || current === "Running") embedStageEl.dataset.mode = "busy";
            else embedStageEl.dataset.mode = "idle";

            stepState(embedStepSubmittedEl, "");
            stepState(embedStepRunningEl, "");
            stepState(embedStepSucceededEl, "");

            if (current === "Submitted" || current === "Queued") {
              stepState(embedStepSubmittedEl, "active");
            } else if (current === "Running") {
              stepState(embedStepSubmittedEl, "done");
              stepState(embedStepRunningEl, "active");
            } else if (current === "Succeeded") {
              stepState(embedStepSubmittedEl, "done");
              stepState(embedStepRunningEl, "done");
              stepState(embedStepSucceededEl, "done");
              embedStepSucceededEl.classList.add("is-active");
            } else if (current === "Failed" || current === "Error") {
              stepState(embedStepSubmittedEl, "done");
              stepState(embedStepRunningEl, "active");
            }

            if (current === "Submitted" || current === "Queued" || current === "Running") {
              const label = message || (current === "Running" ? "Executing Work..." : "Waiting for queue admit...");
              embedPhaseMetaEl.textContent = label + " elapsed " + formatElapsedSeconds(elapsedSec);
            } else if (current === "Succeeded") {
              embedPhaseMetaEl.textContent = "Completed in " + formatElapsedSeconds(elapsedSec) + ".";
            } else if (current === "Failed" || current === "Error") {
              embedPhaseMetaEl.textContent = message || "Execution failed.";
            } else {
              embedPhaseMetaEl.textContent = message || "Waiting for artifact.";
            }
          }

          function setEmbedWaitingState(visible, phase, message) {
            if (!embedFrameEl || !embedStageEl) return;
            if (visible) {
              embedStageEl.style.display = "block";
              embedFrameEl.style.display = "none";
              updateEmbedStage(phase || "Submitted", message || "Waiting for artifact...");
              return;
            }
            embedStageEl.style.display = "none";
            embedFrameEl.style.display = "block";
          }

          function readEmbedText(el) {
            if (!el) return "";
            const t = String(el.textContent || "").trim();
            if (!t || t === "(not found yet)" || t === "(empty)" || t === "Waiting...") return "";
            return t;
          }

          function latestUserInputFromInstructionsCSV(csvText) {
            if (typeof csvText !== "string" || !csvText.trim()) return "";
            const lines = csvText.split(/\r?\n/).map((l) => String(l || "").trim()).filter(Boolean);
            for (let i = lines.length - 1; i >= 0; i--) {
              const line = lines[i];
              if (!line || /^timestamp_unix,role,text$/i.test(line)) continue;
              const m = line.match(/^([0-9]+),([^,]+),"(.*)"$/);
              let role = "";
              let text = "";
              if (m) {
                role = String(m[2] || "").trim().toUpperCase();
                text = String(m[3] || "");
              } else {
                const parts = line.split(",");
                if (parts.length < 3) continue;
                role = String(parts[1] || "").trim().toUpperCase();
                text = parts.slice(2).join(",");
                if (text.startsWith("\"") && text.endsWith("\"") && text.length >= 2) {
                  text = text.slice(1, -1);
                }
              }
              if (role !== "USER") continue;
              return text.replace(/""/g, "\"").replace(/\\n/g, "\n").trim();
            }
            return "";
          }

          function setFollowupBusy(busy) {
            if (!followupBtnEl || !followupInputEl) return;
            const disabled = busy || !followupAllowed;
            followupBtnEl.disabled = disabled;
            followupInputEl.disabled = disabled;
            followupBtnEl.textContent = busy ? "Submitting..." : "Send Follow-up";
          }

          function setFollowupAllowed(allowed, waitingMessage) {
            followupAllowed = !!allowed;
            setFollowupBusy(false);
            if (!followupAllowed && followupStatusEl && waitingMessage) {
              followupStatusEl.textContent = waitingMessage;
            }
            if (followupAllowed && followupStatusEl && /^Work /.test(followupStatusEl.textContent || "")) {
              followupStatusEl.textContent = "";
            }
          }

          async function initEmbedMode() {
            if (playgroundShellEl) playgroundShellEl.style.display = "none";
            if (embedShellEl) embedShellEl.style.display = "block";

            const params = new URLSearchParams(window.location.search);
            const workName = (workNameFromPath || params.get("work") || "").trim();
            if (workName) rememberWorkID(workName);
            setFollowupAllowed(false, "Work is not ready yet.");
            let artifactUrl = normalizeArtifactUrl(params.get("artifact") || params.get("url"));
            if (normalizedPath === "/embed" && workNameFromPath === "" && workName && !artifactUrl) {
              window.history.replaceState(null, "", embedURLForWork(workName));
            }

            if (!artifactUrl && workName) {
              try {
                const st = await fetchStatus(workName);
                artifactUrl = normalizeArtifactUrl(st.artifactUrl || "");
              } catch (_) {}
            }
            if (!artifactUrl && workName) artifactUrl = artifactUrlForWork(workName);
            if (!artifactUrl) {
              embedMetaEl.textContent = "Use ?work=<work-name>.";
              embedUserEl.textContent = "";
              embedDialogueEl.textContent = "";
              embedAgentEl.textContent = "";
              if (embedFollowupEl) embedFollowupEl.style.display = "none";
              if (embedOpenEl) embedOpenEl.style.display = "none";
              return;
            }

            let frameReady = false;
            embedWorkStartedAt = Date.now();
            setEmbedWaitingState(true, "Submitted", "Waiting for artifact...");
            if (workName) {
              embedOpenEl.style.display = "";
              embedOpenEl.href = embedURLForWork(workName);
              embedOpenEl.textContent = "Open Work";
              if (embedFollowupEl) embedFollowupEl.style.display = "";
            } else {
              embedOpenEl.style.display = "none";
              if (embedFollowupEl) embedFollowupEl.style.display = "none";
              setEmbedWaitingState(false);
              embedFrameEl.src = artifactUrl;
              frameReady = true;
            }
            embedMetaEl.textContent = workName ? ("Work: " + workName + " (loading...)") : "Loading artifact...";

            if (workName && followupBtnEl && followupInputEl) {
              followupBtnEl.onclick = async () => {
                const prompt = followupInputEl.value.trim();
                if (!prompt) {
                  if (followupStatusEl) followupStatusEl.textContent = "Please input follow-up text.";
                  return;
                }
                const contextParts = [];
                const userText = readEmbedText(embedUserEl);
                const dialogueText = readEmbedText(embedDialogueEl);
                const agentText = readEmbedText(embedAgentEl);
                if (userText) contextParts.push("[USER]\n" + userText);
                if (dialogueText) contextParts.push("[DIALOGUE]\n" + dialogueText);
                if (agentText) contextParts.push("[AGENT LOG]\n" + agentText);
                const followupContext = contextParts.join("\n\n");

                setFollowupBusy(true);
                if (followupStatusEl) followupStatusEl.textContent = "Submitting follow-up...";
                try {
                  const res = await fetch("/api/submit-agent", {
                    method: "POST",
                    cache: "no-store",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                      prompt,
                      parentWork: workName,
                      followupContext
                    })
                  });
                  const j = await res.json();
                  if (!res.ok) throw new Error(j.error || ("submit failed: " + res.status));
                  rememberWorkID(j.workName);
                  if (followupStatusEl) followupStatusEl.textContent = "Submitted. Opening next work...";
                  window.location.href = embedURLForWork(j.workName);
                } catch (e) {
                  if (followupStatusEl) followupStatusEl.textContent = "Error: " + e.message;
                  setFollowupBusy(false);
                }
              };
            }

            const refresh = async () => {
              let phase = "";
              let message = "";
              if (workName) {
                try {
                  const st = await fetchStatus(workName);
                  phase = st.phase || "Submitted";
                  message = st.message || "";
                  const statusArtifact = normalizeArtifactUrl(st.artifactUrl || "");
                  if (statusArtifact) artifactUrl = statusArtifact;
                  embedMetaEl.textContent = "Work: " + workName + " / phase=" + phase + (message ? (" / " + message) : "");
                } catch (e) {
                  phase = "Running";
                  message = "status error: " + e.message;
                  embedMetaEl.textContent = "Work: " + workName + " / " + message;
                }
              }
              const isTerminalPhase = workName && (phase === "Succeeded" || phase === "Failed" || phase === "Error");

              if (!frameReady && workName) {
                if (phase === "Succeeded") {
                  setEmbedWaitingState(false);
                  embedFrameEl.src = artifactUrl;
                  frameReady = true;
                } else if (phase === "Failed" || phase === "Error") {
                  setEmbedWaitingState(true, phase || "Failed", "Work failed before artifact became available.");
                } else if (phase === "Running") {
                  setEmbedWaitingState(true, "Running", "Work is running. Opening artifact when ready...");
                } else if (phase === "Queued" || phase === "Submitted") {
                  setEmbedWaitingState(true, phase || "Submitted", "Work submitted. Waiting for queue admission...");
                } else {
                  setEmbedWaitingState(true, phase || "Waiting", "Waiting for work status...");
                }
              }

              const canReadArtifacts = !workName || phase === "Succeeded" || phase === "Failed" || phase === "Error";
              const instructionCSV = await fetchText(artifactUrl + "logs/instructions.csv");
              const quickUserInput = latestUserInputFromInstructionsCSV(instructionCSV);
              if (workName) {
                if (canReadArtifacts) {
                  setFollowupAllowed(true, "");
                } else {
                  setFollowupAllowed(false, "Work phase is " + (phase || "Submitted") + ". Follow-up is enabled after completion.");
                }
              }
              if (!canReadArtifacts) {
                embedUserEl.textContent = quickUserInput || "(not found yet)";
                embedDialogueEl.textContent = "(not found yet)";
                embedAgentEl.textContent = "(not found yet)";
                return !isTerminalPhase;
              }

              const user = await fetchText(artifactUrl + "user-input.txt");
              const dialogue = await fetchText(artifactUrl + "dialogue.txt");
              const agent = await fetchText(artifactUrl + "agent.log");

              const resolvedUser = user === null ? quickUserInput : (user || quickUserInput);
              embedUserEl.textContent = resolvedUser ? resolvedUser : "(not found yet)";
              embedDialogueEl.textContent = dialogue === null ? "(not found yet)" : (dialogue || "(empty)");
              embedAgentEl.textContent = agent === null ? "(not found yet)" : (agent || "(empty)");
              return !isTerminalPhase;
            };

            stopEmbedRefreshTicker();
            const keepPolling = await refresh();
            if (keepPolling) {
              embedRefreshTimer = setInterval(async () => {
                const keep = await refresh();
                if (!keep) stopEmbedRefreshTicker();
              }, 2500);
            }
          }

          function setBusy(busy) {
            submitBtn.disabled = busy;
            submitBtn.textContent = busy ? "Submitting..." : "Generate Map";
          }

          function stopStageTicker() {
            if (stageTicker) {
              clearInterval(stageTicker);
              stageTicker = null;
            }
          }

          function stopEmbedRefreshTicker() {
            if (embedRefreshTimer) {
              clearInterval(embedRefreshTimer);
              embedRefreshTimer = null;
            }
          }

          function stopAllTimers() {
            stopStageTicker();
            stopEmbedRefreshTicker();
          }

          function formatElapsedSeconds(sec) {
            const s = Math.max(0, Math.floor(sec));
            const mm = String(Math.floor(s / 60)).padStart(2, "0");
            const ss = String(s % 60).padStart(2, "0");
            return mm + ":" + ss;
          }

          function stepState(el, mode) {
            el.classList.remove("is-active", "is-done");
            if (mode === "active") el.classList.add("is-active");
            if (mode === "done") el.classList.add("is-done");
          }

          function progressByPhase(phase, elapsedSec) {
            if (phase === "Submitted") return Math.min(45, 15 + elapsedSec * 1.8);
            if (phase === "Running") return Math.min(95, 58 + elapsedSec * 0.8);
            if (phase === "Succeeded") return 100;
            if (phase === "Failed" || phase === "Error") return 100;
            return 3;
          }

          function updateStage(phase, message) {
            lastPhase = phase || "Idle";
            const elapsedSec = workStartedAt > 0 ? (Date.now() - workStartedAt) / 1000 : 0;
            const progress = progressByPhase(lastPhase, elapsedSec);
            progressFillEl.style.width = progress.toFixed(1) + "%";
            phaseChipEl.textContent = lastPhase.toUpperCase();

            if (lastPhase === "Succeeded") stageEl.dataset.mode = "done";
            else if (lastPhase === "Failed" || lastPhase === "Error") stageEl.dataset.mode = "error";
            else if (lastPhase === "Submitted" || lastPhase === "Running") stageEl.dataset.mode = "busy";
            else stageEl.dataset.mode = "idle";

            stepState(stepSubmittedEl, "");
            stepState(stepRunningEl, "");
            stepState(stepSucceededEl, "");

            if (lastPhase === "Submitted") {
              stepState(stepSubmittedEl, "active");
            } else if (lastPhase === "Running") {
              stepState(stepSubmittedEl, "done");
              stepState(stepRunningEl, "active");
            } else if (lastPhase === "Succeeded") {
              stepState(stepSubmittedEl, "done");
              stepState(stepRunningEl, "done");
              stepState(stepSucceededEl, "done");
              stepSucceededEl.classList.add("is-active");
            } else if (lastPhase === "Failed" || lastPhase === "Error") {
              stepState(stepSubmittedEl, "done");
              stepState(stepRunningEl, "active");
            }

            if (lastPhase === "Submitted" || lastPhase === "Running") {
              const label = message || (lastPhase === "Submitted" ? "Waiting for queue admit..." : "Executing Work...");
              phaseMetaEl.textContent = label + " elapsed " + formatElapsedSeconds(elapsedSec);
            } else if (lastPhase === "Succeeded") {
              phaseMetaEl.textContent = "Completed in " + formatElapsedSeconds(elapsedSec) + ". Redirecting...";
            } else if (lastPhase === "Failed" || lastPhase === "Error") {
              phaseMetaEl.textContent = message || "Execution failed.";
            } else {
              phaseMetaEl.textContent = "Waiting for input.";
            }
          }

          function startStageTicker() {
            stopStageTicker();
            stageTicker = setInterval(() => {
              if (lastPhase === "Submitted" || lastPhase === "Running") {
                updateStage(lastPhase, "");
              }
            }, 400);
          }

          if (isEmbedMode) {
            renderRecentWorks();
            initEmbedMode().catch((e) => {
              if (embedMetaEl) embedMetaEl.textContent = "Embed init failed: " + e.message;
            });
          } else {
            renderRecentWorks();
            form.addEventListener("submit", async (ev) => {
              ev.preventDefault();
              stopAllTimers();
              const prompt = input.value.trim();
              if (!prompt) {
                statusEl.textContent = "Please input text.";
                return;
              }
              setBusy(true);
              workStartedAt = Date.now();
              updateStage("Submitted", "Submitting Work...");
              startStageTicker();
              statusEl.textContent = "Submitting Work...";
              workNameEl.textContent = "";
              artifactEl.textContent = "";

              try {
                const res = await fetch("/api/submit-agent", {
                  method: "POST",
                  cache: "no-store",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ prompt })
                });
                const j = await res.json();
                if (!res.ok) {
                  throw new Error(j.error || ("submit failed: " + res.status));
                }
                const workName = j.workName;
                rememberWorkID(workName);
                workNameEl.textContent = "Work: " + workName;
                artifactEl.textContent = "Redirecting to /works/" + workName + "...";
                updateStage("Submitted", "Submitted. Opening embed...");
                statusEl.textContent = "Work in progress... (Submitted)";
                window.location.href = embedURLForWork(workName);
                return;
              } catch (e) {
                stopAllTimers();
                updateStage("Error", e.message);
                statusEl.textContent = "Error: " + e.message;
                setBusy(false);
              }
            });

            clearBtn.addEventListener("click", () => {
              input.value = "";
              statusEl.textContent = "Ready.";
              workNameEl.textContent = "";
              artifactEl.textContent = "";
              workStartedAt = 0;
              updateStage("Idle", "");
              stopAllTimers();
              setBusy(false);
              input.focus();
            });

            document.querySelectorAll(".eg").forEach((btn) => {
              btn.addEventListener("click", () => {
                input.value = btn.textContent.trim();
                input.focus();
              });
            });

            updateStage("Idle", "");
          }
        </script>
      </body>
    </html>
